	//调用ResolveDomainToIPsWithHosts函数解析域名
	if len(proxyoptions) > 0 {
		// 如果启用了上游IP解析功能，则使用新的解析逻辑
		if upstreamResolveIPs {
			// 对于上游代理连接，使用IP地址解析
			resolvedIPs, err := ResolveUpstreamDomainToIPs(addr, proxyoptions, dnsCache)
			if err != nil {
				log.Printf("Failed to resolve upstream domain %s: %v, falling back to domain connection", addr, err)
				// 回退到原有的域名连接方式
			} else if len(resolvedIPs) > 0 {
				// 使用解析出的IP地址进行连接尝试
				hostname, port, err := net.SplitHostPort(addr)
				if err != nil {
					return nil, err
				}

				Shuffle(resolvedIPs)
				for i, serverIP := range resolvedIPs {
					newAddr := net.JoinHostPort(serverIP.String(), port)
					dialer := &net.Dialer{}
					connection, err1 := dialer.DialContext(ctx, network, newAddr)

					if err1 != nil {
						log.Printf("Failed to connect to upstream IP %s: %v", serverIP, err1)
						continue
					} else {
						log.Printf("Successfully connected to upstream address=%s via resolved IP=%s", addr, serverIP)
						return connection, err1
					}
				}
				log.Printf("All resolved upstream IPs failed for address=%s, falling back to domain connection", addr)
			}
		}

		// 原有的解析逻辑，作为回退选项
		//		_, port, err := net.SplitHostPort(addr)
		//		if err != nil {
		//			return nil, err
		//		}
		//		// 用指定的 IP 地址和原端口创建新地址
		//		newAddr := net.JoinHostPort(serverIP, port)
		//		// 创建 net.Dialer 实例
		//		dialer := &net.Dialer{}
		//		// 发起连接
		//		return dialer.DialContext(ctx, network, newAddr)
		var ctx = context.Background()
		return Proxy_net_DialContext(ctx, network, addr, proxyoptions, dnsCache, upstreamResolveIPs, Proxy,tranportConfigurations...)
	} else {
159,169p
		connection, err1 := net.Dial(network, addr)

